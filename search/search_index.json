{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PZip","text":"<p>PZip is an encrypted file format (with optional compression), a command-line tool, and a Python file-like interface.</p>"},{"location":"#installation","title":"Installation","text":"<p>PZip is available on PyPI:</p> <p><code>pip install pzip</code></p>"},{"location":"#command-line-usage","title":"Command Line Usage","text":"<p>For a full list of options, run <code>pzip -h</code>. Basic usage is summarized below:</p> <pre><code>pzip --key keyfile sensitive_data.csv\npzip --key keyfile sensitive_data.csv.pz\n</code></pre> <p>Piping and outputting to stdout is also supported:</p> <pre><code>tar cf - somedir | pzip -z --key keyfile -o somedir.pz\npzip --key keyfile -c somedir.pz | tar xf -\n</code></pre> <p>PZip will generate an encryption key automatically, if you want:</p> <pre><code>pzip -a sensitive_data.csv\nencrypting with password: HgHs4OIm4zGXkch6lTBIqg\n\npzip -p HgHs4OIm4zGXkch6lTBIqg sensitive_data.csv.pz\n</code></pre>"},{"location":"#python-usage","title":"Python Usage","text":"<pre><code>import os, pzip\n\nkey = pzip.Key(os.urandom(32))\n\nwith pzip.open(\"myfile.pz\", \"wb\", key=key) as f:\n    f.write(b\"sensitive data\")\n\nwith pzip.open(\"myfile.pz\", \"rb\", key=key) as f:\n    print(f.read())\n</code></pre> <p>To encrypt using a password instead of a random key (and thus use PBKDF2 instead of HKDF for key derivation):</p> <pre><code>with pzip.open(\"myfile.pz\", \"wb\", key=pzip.Password(\"secret\")) as f:\n    f.write(b\"hello world\")\n</code></pre> <p>By default, PZip will append the total plaintext length to the end of the file, both as a final integrity check, and a way for applications to quickly get the original file size. However, you can disable this by passing <code>append_length=False</code> when opening a file/stream for writing:</p> <pre><code>with pzip.open(output_stream, \"wb\", key=secret, append_length=False) as f:\n    f.write(plaintext)\n</code></pre>"},{"location":"encryption/","title":"Encryption","text":""},{"location":"encryption/#overview","title":"Overview","text":"<p>PZip uses AES-GCM with 256-bit keys, 96-bit nonces (by default), and 128-bit authentication tags. Keys are derived using one of the following, based on the source key material:</p> <ul> <li>PBKDF2-SHA256 with a configurable iteration count (currently 600,000) if the key material is a password</li> <li>HKDF-SHA256 if the key material is a random key</li> </ul> <p>PZip also has the option to use raw keys with no derivation.</p> <p>The PZip format is essentially an implemetation of the STREAM protocol, a nonce-based OAE scheme.</p> <p>A random 96-bit nonce is generated by default for each file, but may also be supplied via the Python interface for systems that can more strongly guarantee uniqueness. When deriving keys, a random 256-bit salt is generated by default, but may also be provided manually.</p> <p>The ciphertext of a PZip file is split into some number of blocks. Each block is independently encrypted, prefixed with the length of the block (and a set of flags), and has a 128-bit AES-GCM authentication tag appended to the end. The nonce for each block (<code>Nb</code>) is calculated as follows, for block number <code>B</code> and original file nonce <code>N</code>:</p> <ol> <li><code>B</code> is converted to a 32-bit big endian unsigned integer, and left padded with zero bits to be the same length as      <code>N</code>.</li> <li><code>N</code> is XOR-ed with <code>B</code> to get the block nonce, <code>Nb</code>.</li> </ol>"},{"location":"format/","title":"File Format","text":""},{"location":"format/#overview","title":"Overview","text":"<p>The PZip file format consists of an 8-byte header, followed by a set of tags, followed by one or more encrypted blocks. Each block is prefixed with its length and flags, and has an authentication tag appended to the end.</p>"},{"location":"format/#header","title":"Header","text":"<p>The header is 8 bytes, arranged as follows:</p> <pre><code>+-----+-----+-----+-----+-----+-----+-----+-----+\n| ID1 | ID2 | VER | FLG | ALG | KDF | CMP | NUM |\n+-----+-----+-----+-----+-----+-----+-----+-----+\n</code></pre> <ul> <li><code>ID1</code>/<code>ID2</code> is always <code>\\x86\\x9E</code> (or <code>\u00b6\u017e</code>)</li> <li><code>VER</code> is the format version, currently 1</li> <li><code>FLG</code> is a bitfield of flags</li> <li><code>ALG</code> is the encryption algorithm used</li> <li><code>KDF</code> is the key derivation function used</li> <li><code>CMP</code> is the compression method used</li> <li><code>NUM</code> is the number of tags immediately following the header</li> </ul>"},{"location":"format/#flags","title":"Flags","text":"Bit Value Description 0 1 Whether the file has an 8-byte (big-endian) plaintext length appended to the end"},{"location":"format/#algorithms","title":"Algorithms","text":"Value Algorithm 1 AES-GCM-256"},{"location":"format/#key-derivation-functions","title":"Key Derivation Functions","text":"Value KDF 0 Raw (no KDF) 1 HKDF-SHA256 2 PBKDF2-SHA256"},{"location":"format/#compression-methods","title":"Compression Methods","text":"Value KDF 0 No compression 1 GZIP"},{"location":"format/#tags","title":"Tags","text":"<p>Tags are used to specify data used in encryption, key derivation, compression, or just user-supplied data. Each tag consists of a two-byte header specifying the signed tag number (-128 to 127) and unsigned tag length (0-255):</p> <pre><code>+-----+-----+-------------------+\n| TAG | LEN | ... LEN bytes ... |\n+-----+-----+-------------------+\n</code></pre> <p>Negative tags are interpreted as big-endian integer values of whatever <code>LEN</code> is specified (i.e. 32-bit for <code>LEN=4</code>). Positive tag numbers are simply interpreted as bytestrings.</p>"},{"location":"format/#tag-values","title":"Tag Values","text":"Tag Description 1 Nonce 2 KDF salt -3 KDF iteration count 4 KDF info parameter 5 Filename 6 Application 7 MIME type 127 Comment"},{"location":"format/#encrypted-blocks","title":"Encrypted Blocks","text":"<p>PZip files are encrypted in some number of variable-length blocks. By default, PZip uses a block size of 2^17 (128 KB), but this may vary per file, or even per block. Each block is prefixed with a 4-byte header. The first byte is a bitfield of flags:</p>"},{"location":"format/#block-flags","title":"Block Flags","text":"Bit Value Description 7 128 Set for last block of the file <p>The remaining 3 bytes is a 24-bit big endian block size, so blocks have an upper size limit of about 16 MB. Each block is also appended with a 16-byte (128-bit) authentication tag (included in the block size). The remainder of the block is encrypted (and potentially compressed) ciphertext.</p>"},{"location":"format/#sample-file","title":"Sample File","text":"<p>Below is a descriptive breakdown of a PZip file containing the bytestring \"Hello, world!\", encrypted with a key derived using PBKDF2 from the password \"pzip\":</p> Bytes (hex) Description B6 9E 01 01 01 02 00 03 Header: Version 1, APPEND_LENGTH, AES-GCM-256, PBKDF2-SHA256, no compression, 3 tags 02 20 Tag 2 (KDF_SALT), length 32 07 4D 65 15 16 E6 8F 05 61 B5 5B 81 37 6F 9E 38 C6 0F 0C DA EA BE 1C BE FC AC 0C 41 4C 45 41 A2 PBKDF2 salt FD 04 Tag -3 (KDF_ITERATIONS) 00 03 0D 40 200,000 iterations 01 0C Tag 1 (NONCE), length 12 53 FB D2 4B F5 D4 28 38 16 13 5F CF AES-GCM Nonce 80 00 00 1D Block header: LAST_BLOCK, length 29 BF 3E C0 AC FC 98 9B 11 09 9F 4A 40 E3 \"Hello, world!\" (encrypted) AD 5D A7 58 62 F9 A2 B1 7A 91 5C 79 D2 E6 C4 B2 AES-GCM authentication tag 00 00 00 00 00 00 00 0D Appended plaintext length (13) <p>You can verify the above example in Python:</p> <pre><code>import binascii, io, pzip\ndata = binascii.unhexlify('B69E0101010200030220074D651516E68F0561B5'\n    '5B81376F9E38C60F0CDAEABE1CBEFCAC0C414C4541A2FD0400030D40010C53'\n    'FBD24BF5D4283816135FCF8000001DBF3EC0ACFC989B11099F4A40E3AD5DA7'\n    '5862F9A2B17A915C79D2E6C4B2000000000000000D'\n)\npzip.open(io.BytesIO(data), \"rb\", key=\"pzip\").read()\n</code></pre>"}]}